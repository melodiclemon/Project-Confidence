<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Variables

// MAKE SURE scr_LoadDialogFromFile has been run before this script runs!
// Note that dialogbubbles displayes /c endsyntax the same as /s.

// variables that can be altered before showing dialog
dialogID = "";
textSpeed = 3; // value should be between 0.1(instant) - 6(slow)
font = font_default; // font to use.
color = c_white; // text &amp; border color
bubbleColor = c_black; // bubbleColor
textSound = -1; // sound to play for each character in the dialog.
                // Won't be used if typewriter is set to false
write = false; // set to true when all variables have been set
typewriter = 1; // 0 == no typewriter, 1 == char by char. 2 == word by word
actor = -1; // id of the actorObject saying the dialog. Not necessary
characterDistance = 20; // distance from the character the dialogbubble 
                        // should be drawn
type = 0; // 0 == normal, 1 == shouting, 2 == thinking
closeable = true; // set to false if the player shouldn't be able to close the
                  // bubble manually
skipable = true; // can the player skip text in this bubble?
fontScale = 0.45; // fontscale, X &amp; Y needs to have the same scale
choices = -1 // -1 if no choices. An array of strings otherwise.

// variables that updates themself
dialog = ""; // current dialog to be written
nextDialogID = ""; // dialogID for the next dialog to be written
dialogLength = 0; // length of current dialog
charactersToDrawCurrentDialog = ""; // string of characters that should be drawn from the current dialog
charactersToDraw = ""; // string of characters that should be drawn
charactersDrawn = 0; // number of characters in the current dialog that should be drawn
previousCharactersDrawn = ""; // characters from previous dialogs that still needs to be drawn
startOfDialog = true; // is thie the start of the dialog row?
newDialog = false; // is there more dialog after this?
endOfDialog = false; // is it the end of the dialog tree?
fontSize = font_get_size(font); // the size of the font used
dialogWidth = 0; // the total width of the dialog
dialogHeight = 0; // the total height of the dialog
bubbleWidth = 0; // the total width of the dialogbubble
bubbleHeight = 0; // the total height of the dialogbubble
bubbleMaxLength = view_wview[0]; // the maximum width of the dialogbubble
closeDelay = 0; // step delay before the dialogbubble closes
splitDialog = 0; // splitString used by word typewriter
splitDialogsToDraw = 0; // number of split_string dialogs to draw
useFontScale = 0; // actual fontScale to use, depending on bubbleType
expectPlayerInput = false // should the player answer to this dialog?
input = -1; // input the player has chosen
loadComplete = false; // if all values above have been set at least once
finish = false; // if the dialog is all done, this should be true
// below are used by the draw GUI event
xCord = x - view_xview[0];
yCord = y - view_yview[0];
yViewOffset = 0;
outlinePadding = 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Destroy ds_list
if (typewriter == 2)
{
    ds_list_destroy(splitDialog);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Increase splitDialogsToDraw
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Finish or continue writing
if (!newDialog)
{
    finish = true;
}
else
{
    previousCharactersDrawn = "";
    charactersToDraw = false;
    endOfDialog = false;
    write = true;
    
    if (typewriter == 2)
    {
        ds_list_clear(splitDialog);
        splitDialogsToDraw = 0;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Destroy instance if actor is invalid
if (actor != -1 &amp;&amp; !instance_exists(actor))
{
    if (!instance_exists(actor))
    {
        if (typewriter == 2) 
        {
            ds_list_destroy(splitDialog);
        }
        instance_destroy();
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>obj_dialogbubble</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Format dialog string
if (startOfDialog == true &amp;&amp; write == true) 
{
    //reset newDialog
    newDialog = false;
    
    //endOfDialog should be true
    endOfDialog = true;
    
    dialog = global.dialog[? dialogID];
    if (!is_undefined(dialog))
    {
        var seperator = "&gt;&gt;&gt;";
        if (string_pos("/i", dialog) != 0)
        {
            seperator = "^^^";
            nextDialogID = dialog;
        } 
        else 
        {
            nextDialogID = string_rtrim(string_extract(dialog, seperator, 1));
        }
        dialog = string_rtrim(string_extract(dialog, seperator, 0));
    }
    else
    {
        // Fail-safe if something goes wrong
        if (typewriter == 2) 
        {
            ds_list_destroy(splitDialog);
        }
        instance_destroy();
        exit;
    }
    
    // format string after need    
    if (string_pos("/s", dialog) != 0 || string_pos("/c", dialog) != 0)
    {
        newDialog = true;
        dialog = string_replace(dialog, "/s", "");
        dialog = string_replace(dialog, "/c", "");
    }
    
    if (string_pos("/e", dialog) != 0)
    {
        dialog = string_replace(dialog, "/e", "");
    }
    
    if (string_pos("/a", dialog) != 0)
    {
        if (nextDialogID != dialog)
        {
            newDialog = true;
        }
        if (string_pos("/as", dialog) != 0)
        {
            closeDelay = room_speed;
            dialog = string_replace(dialog, "/as", "");    
        }
        else if (string_pos("/af", dialog) != 0)
        {
            closeDelay = room_speed * 2;
            dialog = string_replace(dialog, "/af", "");
        }
        else
        {
            closeDelay = 1;
            dialog = string_replace(dialog, "/a", "");
        }
    }
    
    if (string_pos("/i", dialog) != 0)
    {
        expectPlayerInput = true;
        dialog = string_replace(dialog, "/i", "");
        var choice = 1;
        while (true) 
        {
            choices[choice - 1] = string_rtrim(string_extract(nextDialogID, "^^^", choice));
            if (choices[choice - 1] == "") 
            {
                break;
            }
            choice++;
        }
    }
    
    if (typewriter == 2) 
    {
        splitDialog = string_split(dialog, " ");
    }
    
    // calculate dialog specific values
    useFontScale = fontScale;
    if (type == 1) 
    {
        useFontScale = fontScale + (fontScale / 2);
    }
    fontSize = font_get_size(font) * useFontScale;
    draw_set_font(font);
    dialogLength = string_length(dialog);
    
    dialogWidth = string_width_ext
    (
        dialog,
        fontSize + fontSize + (fontSize / 2),
        bubbleMaxLength
    ) * useFontScale;
    
    dialogHeight = string_height_ext
    (
        dialog,
        fontSize + fontSize + (fontSize / 2),
        bubbleMaxLength
    ) * useFontScale;
    
    bubbleWidth = dialogWidth + fontSize * 2;
    
    if (expectPlayerInput) 
    {
        bubbleHeight = dialogHeight + (fontSize * 2) + string_height(choices[0]); 
    }
    else
    {
        bubbleHeight = dialogHeight + (fontSize * 1.5);
    }
    
    // To make the values easier to use
    if (type == 1) 
    {
        bubbleWidth = closest_whole_multiply(bubbleWidth, 10);
        bubbleHeight = closest_whole_multiply(bubbleHeight, 10);
    }
    
    startOfDialog = false;
    loadComplete = true;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Decide characters to draw
if (write == true) 
{
    if (typewriter == 0 || typewriter == 1) 
    {
        // if typewriter is false, we want to display the whole message right away
        if (typewriter == 0)
        {
            charactersToDrawCurrentDialog = dialog;
            charactersToDraw = previousCharactersDrawn + dialog;
            charactersDrawn = dialogLength + 1;
        }
        
        // if there's still characters left to draw
        if (floor(charactersDrawn) &lt;= dialogLength) 
        {
            // copy all characters that should be drawn this step
            charactersToDrawCurrentDialog = string_copy(dialog, 
                                                        0, 
                                                        charactersDrawn);
        
            // if there is a text sound and if a new character will be written                                       
            if (textSound != -1)
            {
                if (typewriter == 1)
                {
                    if (charactersDrawn &lt; floor(charactersDrawn + (1 / textSpeed)))
                    {
                        audio_play_sound(textSound, 10, false);
                    }
                }
            }
                                                        
            charactersDrawn += 1 / textSpeed;
            charactersToDraw = previousCharactersDrawn + charactersToDrawCurrentDialog;
        }
        else
        {
            // if we are at the end of the dialog
            if (newDialog)
            {
                // fail-safe
                charactersToDraw = previousCharactersDrawn + dialog;
            
                // update variables necessary for reading a new dialog
                dialogID = nextDialogID;
                previousCharactersDrawn += dialog;
                
                // reset variables necessary for reading a new dialog
                charactersToDrawCurrentDialog = "";
                startOfDialog = true;
                charactersDrawn = 0;
            }
            if (endOfDialog)
            {
                write = false;
            }
        }
    }
    else
    {
        // typewriter == 2
        // if there's still words to draw
        if (splitDialogsToDraw &lt;= ds_list_size(splitDialog))
        {
            // copy all words that should be printed
            charactersToDrawCurrentDialog = "";
            for (var word = 0; word &lt; splitDialogsToDraw; word++)
            {
                charactersToDrawCurrentDialog += splitDialog[| word];
                if (word != ds_list_size(splitDialog)) 
                {
                    charactersToDrawCurrentDialog += " ";
                }
            }
            
            if (alarm[1] == -1) 
            {
                if (splitDialogsToDraw &lt;= ds_list_size(splitDialog))
                {
                    alarm[1] = room_speed / textSpeed;
                    
                    if (textSound != -1)
                    {
                        audio_play_sound(textSound, 10, false);
                    }
                    
                    splitDialogsToDraw++;
                }
            }
            
            charactersToDraw = previousCharactersDrawn + charactersToDrawCurrentDialog;
        }
        else
        {
            // if we are at the end of the dialog
            if (newDialog)
            {
                // fail-safe
                charactersToDraw = previousCharactersDrawn + dialog;
            
                // update variables necessary for reading a new dialog
                dialogID = nextDialogID;
                previousCharactersDrawn += charactersToDrawCurrentDialog;
                
                // reset variables necessary for reading a new dialog
                charactersToDrawCurrentDialog = "";
                startOfDialog = true;
                charactersDrawn = 0;
                splitDialog = 0;
                ds_list_clear(splitDialog);
            }
            if (endOfDialog)
            {
                write = false;
            }
        }
    }
    
    // if the bubble should close automagically
    if (endOfDialog)
    {
        if (!write)
        {
            if (closeDelay != 0)
            {
                if (alarm[0] == -1) 
                {
                    alarm[0] = closeDelay;
                }
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Player controls
if (mouse_check_button_released(mb_left))
{
    if (write)
    {
        if (skipable)
        {
            charactersToDraw = previousCharactersDrawn + dialog;
            charactersDrawn = dialogLength;
            if (typewriter == 2)
            {
                splitDialogsToDraw = ds_list_size(splitDialog);
            }
        }
    }
    else if (newDialog)
    {
        if (closeable)
        {
            if (!write)
            {
                if (endOfDialog)
                {
                    previousCharactersDrawn = "";
                    charactersToDraw = "";
                    endOfDialog = false;
                    write = true;
                    if (typewriter == 2)
                    {
                        ds_list_clear(splitDialog);
                        splitDialogsToDraw = 0;
                    }
                }
            }
        }
    }
    else if (endOfDialog &amp;&amp; !write &amp;&amp; closeable)
    {
        if (closeable)
        {
            if(!write)
            {
                finish = true;
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw dialogbubble type 0

if (type == 0)
{
    if (loadComplete)
    {
        if(actor != -1) 
        {
            xCord = actor.x - (bubbleWidth / 2) - view_xview[0];
            yCord = actor.y - bubbleHeight - actor.sprite_yoffset - characterDistance - view_yview[0];
            
            if (yCord &lt; view_yview[view_current])
            {
                yViewOffset = bubbleHeight + actor.sprite_yoffset + characterDistance;
            }
        }
        
        // outline
        draw_set_color(color);
        draw_roundrect_ext
        (
            xCord - outlinePadding, 
            yCord + yViewOffset - outlinePadding, 
            xCord + bubbleWidth + outlinePadding, 
            yCord + bubbleHeight + yViewOffset + outlinePadding, 
            fontSize, 
            fontSize, 
            false
        );
        
        // fill
        draw_set_color(bubbleColor);
        draw_roundrect_ext
        (
            xCord, 
            yCord + yViewOffset, 
            xCord + bubbleWidth, 
            yCord + bubbleHeight + yViewOffset, 
            fontSize, 
            fontSize, 
            false
        );
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw dialogbubble type 1

if (type == 1)
{   
    if (loadComplete)
    {
        if(actor != -1) 
        {
            xCord = actor.x - (bubbleWidth / 2) - view_xview[0];
            yCord = actor.y - bubbleHeight - actor.sprite_yoffset - characterDistance - view_yview[0];
            
            if (yCord - fontSize &lt; view_yview[view_current])
            {
                yViewOffset = bubbleHeight + actor.sprite_yoffset + characterDistance;
            }
        }
        
        // cosmetic loop 
        // Top left corner
        // outline
        draw_set_color(color);
        draw_triangle
        (
            xCord,
            yCord + fontSize  + yViewOffset + outlinePadding,
            xCord,
            yCord + yViewOffset,
            xCord - fontSize - outlinePadding,
            yCord - fontSize + yViewOffset - outlinePadding,
            false
        );
        draw_triangle
        (
            xCord + (fontSize * 2) + outlinePadding,
            yCord + yViewOffset,
            xCord,
            yCord + yViewOffset,
            xCord - fontSize - outlinePadding,
            yCord - fontSize + yViewOffset - outlinePadding,
            false
        );
        
        // fill
        draw_set_color(bubbleColor);
        draw_triangle
        (
            xCord,
            yCord + fontSize  + yViewOffset,
            xCord,
            yCord + yViewOffset,
            xCord - fontSize,
            yCord - fontSize + yViewOffset,
            false
        );
        draw_triangle
        (
            xCord + (fontSize * 2),
            yCord + yViewOffset,
            xCord,
            yCord + yViewOffset,
            xCord - fontSize,
            yCord - fontSize + yViewOffset,
            false
        );
        
        // Top right corner
        // outline
        draw_set_color(color);
        draw_triangle
        (
            xCord + bubbleWidth + 1,
            yCord + fontSize + yViewOffset + outlinePadding,
            xCord + bubbleWidth + 1,
            yCord + yViewOffset,
            xCord + bubbleWidth + fontSize + outlinePadding,
            yCord - fontSize + yViewOffset - outlinePadding,
            false
        );
        draw_triangle
        (
            xCord + bubbleWidth - (fontSize * 2) - outlinePadding,
            yCord + yViewOffset,
            xCord + bubbleWidth + 1,
            yCord + yViewOffset,
            xCord + bubbleWidth + fontSize + outlinePadding,
            yCord - fontSize + yViewOffset - outlinePadding,
            false
        );
        
        // fill
        draw_set_color(bubbleColor);
        draw_triangle
        (
            xCord + bubbleWidth + 1,
            yCord + fontSize + yViewOffset,
            xCord + bubbleWidth + 1,
            yCord + yViewOffset,
            xCord + bubbleWidth + fontSize,
            yCord - fontSize + yViewOffset,
            false
        );
        draw_triangle
        (
            xCord + bubbleWidth - (fontSize * 2),
            yCord + yViewOffset,
            xCord + bubbleWidth + 1,
            yCord + yViewOffset,
            xCord + bubbleWidth + fontSize,
            yCord - fontSize + yViewOffset,
            false
        );
        
        // Bottom right corner
        // outline
        draw_set_color(color);
        draw_triangle
        (
            xCord + bubbleWidth + 1,
            yCord + bubbleHeight - fontSize + yViewOffset - outlinePadding,
            xCord + bubbleWidth + 1,
            yCord + bubbleHeight + yViewOffset,
            xCord + bubbleWidth + fontSize + outlinePadding,
            yCord + bubbleHeight + fontSize + yViewOffset + outlinePadding,
            false
        );
        draw_triangle
        (
            xCord + bubbleWidth - (fontSize * 2) - outlinePadding,
            yCord + bubbleHeight + yViewOffset,
            xCord + bubbleWidth + 1,
            yCord + bubbleHeight + yViewOffset,
            xCord + bubbleWidth + fontSize + outlinePadding,
            yCord + bubbleHeight + fontSize + yViewOffset + outlinePadding,
            false
        );
        
        // fill
        draw_set_color(bubbleColor);
        draw_triangle
        (
            xCord + bubbleWidth + 1,
            yCord + bubbleHeight - fontSize + yViewOffset,
            xCord + bubbleWidth + 1,
            yCord + bubbleHeight + yViewOffset,
            xCord + bubbleWidth + fontSize,
            yCord + bubbleHeight + fontSize + yViewOffset,
            false
        );
        draw_triangle
        (
            xCord + bubbleWidth - (fontSize * 2),
            yCord + bubbleHeight + yViewOffset,
            xCord + bubbleWidth + 1,
            yCord + bubbleHeight + yViewOffset,
            xCord + bubbleWidth + fontSize,
            yCord + bubbleHeight + fontSize + yViewOffset,
            false
        );
        
        // Bottom left corner
        // outline
        draw_set_color(color);
        draw_triangle
        (
            xCord,
            yCord + bubbleHeight - fontSize + yViewOffset - outlinePadding,
            xCord,
            yCord + bubbleHeight + yViewOffset,
            xCord - fontSize - outlinePadding,
            yCord + bubbleHeight + fontSize + yViewOffset + outlinePadding,
            false
        );
        draw_triangle
        (
            xCord + (fontSize * 2) + outlinePadding,
            yCord + bubbleHeight + yViewOffset,
            xCord,
            yCord + bubbleHeight + yViewOffset,
            xCord - fontSize - outlinePadding,
            yCord + bubbleHeight + fontSize + yViewOffset + outlinePadding,
            false
        );
        
        // fill
        draw_set_color(bubbleColor);
        draw_triangle
        (
            xCord,
            yCord + bubbleHeight - fontSize + yViewOffset,
            xCord,
            yCord + bubbleHeight + yViewOffset,
            xCord - fontSize,
            yCord + bubbleHeight + fontSize + yViewOffset,
            false
        );
        draw_triangle
        (
            xCord + (fontSize * 2),
            yCord + bubbleHeight + yViewOffset,
            xCord,
            yCord + bubbleHeight + yViewOffset,
            xCord - fontSize,
            yCord + bubbleHeight + fontSize + yViewOffset,
            false
        );
        
        // Top and bottom
        var loopAmount = 6;
        var halfSpikeLength = (floor(bubbleWidth) / loopAmount) / 2;
        for (var loopCount = 0; loopCount &lt; loopAmount; loopCount++)
        {    
            // Top
            // outline
            draw_set_color(color);
            draw_triangle
            (
                xCord + (halfSpikeLength * loopCount * 2) - outlinePadding,
                yCord + yViewOffset,
                xCord + (halfSpikeLength * 2) + (halfSpikeLength * loopCount * 2) + outlinePadding,
                yCord + yViewOffset,
                xCord + halfSpikeLength + (halfSpikeLength * loopCount * 2),
                yCord - fontSize + yViewOffset - outlinePadding,
                false
            );
            
            // fill
            draw_set_color(bubbleColor);
            draw_triangle
            (
                xCord + (halfSpikeLength * loopCount * 2),
                yCord + yViewOffset,
                xCord + (halfSpikeLength * 2) + (halfSpikeLength * loopCount * 2),
                yCord + yViewOffset,
                xCord + halfSpikeLength + (halfSpikeLength * loopCount * 2),
                yCord - fontSize + yViewOffset,
                false
            );
            
            // Bottom
            // outline
            draw_set_color(color);
            draw_triangle
            (
                xCord + (halfSpikeLength * loopCount * 2) - outlinePadding,
                yCord + bubbleHeight + yViewOffset,
                xCord + (halfSpikeLength * 2) + (halfSpikeLength * loopCount * 2) + outlinePadding,
                yCord + bubbleHeight + yViewOffset,
                xCord + halfSpikeLength + (halfSpikeLength * loopCount * 2),
                yCord + bubbleHeight + fontSize + yViewOffset + outlinePadding,
                false
            );
            
            // fill
            draw_set_color(bubbleColor);
            draw_triangle
            (
                xCord + (halfSpikeLength * loopCount * 2),
                yCord + bubbleHeight + yViewOffset,
                xCord + (halfSpikeLength * 2) + (halfSpikeLength * loopCount * 2),
                yCord + bubbleHeight + yViewOffset,
                xCord + halfSpikeLength + (halfSpikeLength * loopCount * 2),
                yCord + bubbleHeight + fontSize + yViewOffset,
                false
            );
        }
        
        // Left and Right
        loopAmount = 3;
        halfSpikeLength = (bubbleHeight / loopAmount) / 2;
        for (var loopCount = 0; loopCount &lt; loopAmount; loopCount++)
        {
            // Left
            // outline
            draw_set_color(color);
            draw_triangle
            (
                xCord,
                yCord + (halfSpikeLength * loopCount * 2) + yViewOffset - outlinePadding,
                xCord,
                yCord + (halfSpikeLength * 2) + (halfSpikeLength * loopCount * 2) + yViewOffset + outlinePadding,
                xCord - fontSize - outlinePadding,
                yCord + halfSpikeLength + (halfSpikeLength * loopCount * 2) + yViewOffset,
                false
            );
            
            // fill
            draw_set_color(bubbleColor);
            draw_triangle
            (
                xCord,
                yCord + (halfSpikeLength * loopCount * 2) + yViewOffset,
                xCord,
                yCord + (halfSpikeLength * 2) + (halfSpikeLength * loopCount * 2) + yViewOffset,
                xCord - fontSize,
                yCord + halfSpikeLength + (halfSpikeLength * loopCount * 2) + yViewOffset,
                false
            );
            
            // Right
            // outline
            draw_set_color(color);
            draw_triangle
            (
                xCord + bubbleWidth,
                yCord + (halfSpikeLength * loopCount * 2) + yViewOffset - outlinePadding,
                xCord + bubbleWidth,
                yCord + (halfSpikeLength * 2) + (halfSpikeLength * loopCount * 2) + yViewOffset + outlinePadding,
                xCord + bubbleWidth + fontSize + outlinePadding,
                yCord + halfSpikeLength + (halfSpikeLength * loopCount * 2) + yViewOffset,
                false
            );
            
            // fill
            draw_set_color(bubbleColor);
            draw_triangle
            (
                xCord + bubbleWidth,
                yCord + (halfSpikeLength * loopCount * 2) + yViewOffset,
                xCord + bubbleWidth,
                yCord + (halfSpikeLength * 2) + (halfSpikeLength * loopCount * 2) + yViewOffset,
                xCord + bubbleWidth + fontSize,
                yCord + halfSpikeLength + (halfSpikeLength * loopCount * 2) + yViewOffset,
                false
            );
        } 
        
        // body
        draw_set_color(bubbleColor);
        draw_rectangle
        (
            xCord, 
            yCord + yViewOffset, 
            xCord + bubbleWidth, 
            yCord + bubbleHeight + yViewOffset - 1,
            false
        );
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw dialogbubble type 2

if (type == 2)
{   
    if (loadComplete)
    {
        if(actor != -1) 
        {
            xCord = actor.x - (bubbleWidth / 2) - view_xview[0];
            yCord = actor.y - bubbleHeight - actor.sprite_yoffset - characterDistance - view_yview[0];
            
            if (yCord - fontSize &lt; view_yview[view_current])
            {
                yViewOffset = bubbleHeight + actor.sprite_yoffset + characterDistance;
            }
        }
        
        // cosmetic loop
        // Top and bottom
        var loopAmount = 6;
        var halfEllipseLength = (floor(bubbleWidth) / loopAmount) / 2;
        for (var loopCount = 0; loopCount &lt; loopAmount; loopCount++)
        {    
            // Top
            // outline
            draw_set_color(color);
            draw_ellipse
            (
                xCord + (halfEllipseLength * loopCount * 2) - outlinePadding,
                yCord - fontSize + yViewOffset - outlinePadding,
                xCord + (halfEllipseLength * 2) + (halfEllipseLength * loopCount * 2) + outlinePadding,
                yCord + fontSize + yViewOffset + outlinePadding,
                false
            );
            
            // fill
            draw_set_color(bubbleColor);
            draw_ellipse
            (
                xCord + (halfEllipseLength * loopCount * 2),
                yCord - fontSize + yViewOffset,
                xCord + (halfEllipseLength * 2) + (halfEllipseLength * loopCount * 2),
                yCord + fontSize + yViewOffset,
                false
            );
            
            // Bottom
            // outline
            draw_set_color(color);
            draw_ellipse
            (
                xCord + (halfEllipseLength * loopCount * 2) - outlinePadding,
                yCord + bubbleHeight - fontSize + yViewOffset - outlinePadding,
                xCord + (halfEllipseLength * 2) + (halfEllipseLength * loopCount * 2) + outlinePadding,
                yCord + bubbleHeight + fontSize + yViewOffset + outlinePadding,
                false
            );
            
            // fill
            draw_set_color(bubbleColor);
            draw_ellipse
            (
                xCord + (halfEllipseLength * loopCount * 2),
                yCord + bubbleHeight - fontSize + yViewOffset,
                xCord + (halfEllipseLength * 2) + (halfEllipseLength * loopCount * 2),
                yCord + bubbleHeight + fontSize + yViewOffset,
                false
            );
        }
        
        // Left and Right
        loopAmount = 3;
        halfEllipseLength = (bubbleHeight / loopAmount) / 2;
        for (var loopCount = 0; loopCount &lt; loopAmount; loopCount++)
        {
            // Left
            // outline
            draw_set_color(color);
            draw_ellipse
            (
                xCord - fontSize - outlinePadding,
                yCord + (halfEllipseLength * loopCount * 2) + yViewOffset - outlinePadding,
                xCord + fontSize + outlinePadding,
                yCord + (halfEllipseLength * 2) + (halfEllipseLength * loopCount * 2) + yViewOffset + outlinePadding,
                false
            );
            
            // fill
            draw_set_color(bubbleColor);
            draw_ellipse
            (
                xCord - fontSize,
                yCord + (halfEllipseLength * loopCount * 2) + yViewOffset,
                xCord + fontSize,
                yCord + (halfEllipseLength * 2) + (halfEllipseLength * loopCount * 2) + yViewOffset,
                false
            );
            
            // Right
            // outline
            draw_set_color(color);
            draw_ellipse
            (
                xCord + bubbleWidth - fontSize - outlinePadding,
                yCord + (halfEllipseLength * loopCount * 2) + yViewOffset - outlinePadding,
                xCord + bubbleWidth + fontSize + outlinePadding,
                yCord + (halfEllipseLength * 2) + (halfEllipseLength * loopCount * 2) + yViewOffset + outlinePadding,
                false
            );
            
            // fill
            draw_set_color(bubbleColor);
            draw_ellipse
            (
                xCord + bubbleWidth - fontSize,
                yCord + (halfEllipseLength * loopCount * 2) + yViewOffset,
                xCord + bubbleWidth + fontSize,
                yCord + (halfEllipseLength * 2) + (halfEllipseLength * loopCount * 2) + yViewOffset,
                false
            );
        } 
        
        // body
        draw_set_color(bubbleColor);
        draw_rectangle
        (
            xCord, 
            yCord + yViewOffset + 1, 
            xCord + bubbleWidth, 
            yCord + bubbleHeight + yViewOffset,
            false
        );
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw dialogbubble type 3

if (type == 3)
{   
    if (loadComplete)
    {
        if(actor != -1) 
        {
            xCord = actor.x - (bubbleWidth / 2) - view_xview[0];
            yCord = actor.y - bubbleHeight - actor.sprite_yoffset - view_yview[0];
            
            if (yCord - fontSize &lt; view_yview[view_current])
            {
                yViewOffset = bubbleHeight + actor.sprite_yoffset;
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw actor marker
if(loadComplete) 
{
    if (actor != -1)
    {
        if (type != 3 &amp;&amp; type != 2)
        {
            var triangleYOffset = 1;
            var trianglePointOffset = actor.sprite_yoffset + view_yview[0];
            var trianglePointPaddingOffset = outlinePadding;
            var fillRectOffset = 1;
            if (yViewOffset != 0)
            {
                triangleYOffset = yViewOffset - bubbleHeight + 1;
                trianglePointOffset = (actor.sprite_yoffset / 2) + view_yview[0];
                trianglePointPaddingOffset *= -1;
                fillRectOffset = 0;
            }
            
            // outline
            draw_set_color(color);
            draw_triangle
            (
                xCord + (bubbleWidth / 2) - (fontSize / 2) - outlinePadding, 
                yCord + bubbleHeight + triangleYOffset, 
                xCord + (bubbleWidth / 2) + (fontSize / 2) + outlinePadding,
                yCord + bubbleHeight + triangleYOffset,
                xCord + (bubbleWidth / 2),
                actor.y - trianglePointOffset + trianglePointPaddingOffset,
                false
            );
            
            // fill
            draw_set_color(bubbleColor);
            draw_rectangle
            (
                xCord + (bubbleWidth / 2) - (fontSize / 2) - outlinePadding, 
                yCord + bubbleHeight + triangleYOffset - (fillRectOffset * 2), 
                xCord + (bubbleWidth / 2) + (fontSize / 2) + outlinePadding,
                yCord + bubbleHeight + triangleYOffset - fillRectOffset,
                false
            );
            draw_triangle
            (
                xCord + (bubbleWidth / 2) - (fontSize / 2), 
                yCord + bubbleHeight + triangleYOffset, 
                xCord + (bubbleWidth / 2) + (fontSize / 2),
                yCord + bubbleHeight + triangleYOffset,
                xCord + (bubbleWidth / 2),
                actor.y - trianglePointOffset,
                false
            );
        }
        else if (type != 3)
        {
            var circlePointOffset = actor.sprite_yoffset + view_wview[0];
            if (yViewOffset != 0)
            {
                circlePointOffset = (actor.sprite_yoffset / 2) + view_wview[0];
            }
            
            // outline
            draw_set_color(color);
            // top
            draw_circle
            (
                xCord + (bubbleWidth / 2),
                yCord + bubbleHeight + fontSize + (characterDistance / 4),
                (fontSize / 2) + outlinePadding,
                false
            );
            
            // bottom
            draw_circle
            (
                xCord + (bubbleWidth / 2),
                yCord + bubbleHeight + fontSize + ((characterDistance / 4) * 3),
                (fontSize / 3) + outlinePadding,
                false
            );
            
            // fill
            draw_set_color(bubbleColor);
            // top
            draw_circle
            (
                xCord + (bubbleWidth / 2),
                yCord + bubbleHeight + fontSize + (characterDistance / 4),
                (fontSize / 2),
                false
            );
            
            // bottom
            draw_circle
            (
                xCord + (bubbleWidth / 2),
                yCord + bubbleHeight + fontSize + ((characterDistance / 4) * 3),
                (fontSize / 3),
                false
            );
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw text
if(loadComplete) {
    draw_set_font(font);
    draw_set_color(color);
    draw_set_valign(fa_top);
    draw_set_halign(fa_left);
    draw_text_ext_transformed
    (
        xCord + fontSize,
        yCord + (fontSize / 1.5) + yViewOffset, 
        charactersToDraw, 
        (fontSize * 2.5),
        (bubbleWidth - fontSize) / useFontScale,
        useFontScale,
        useFontScale,
        0,
    );
    
    if (!write)
    {
        if (expectPlayerInput)
        {
            var choiceString = "";
            var choiceLength = (fontSize * 3);
            
            // -1, since the last place in the array is always an empty string
            for (i = 0; i &lt; array_length_1d(choices) - 1; i++)
            {
                draw_text_transformed
                (
                    xCord + choiceLength,
                    yCord + (fontSize * 2) + yViewOffset + dialogHeight,
                    choices[i],
                    useFontScale,
                    useFontScale,
                    0,
                )
                    
                var buttonArea = point_in_rectangle
                (
                    mouse_x - view_xview[0],
                    mouse_y - view_yview[0],
                    xCord + choiceLength - fontSize,
                    yCord + fontSize + yViewOffset + dialogHeight,
                    xCord + choiceLength + fontSize + (string_width(choices[i]) * fontScale),
                    yCord + (fontSize * 3) + yViewOffset + dialogHeight + (string_height(choices[i]) * fontScale)
                );
                
                if (buttonArea) 
                {
                    draw_triangle
                    (
                        xCord + fontSize + choiceLength - (fontSize * 2.5), 
                        yCord + (fontSize * 2) + yViewOffset + dialogHeight, 
                        xCord + fontSize + choiceLength - (fontSize * 2.5),
                        yCord + (fontSize * 4) + yViewOffset + dialogHeight,
                        xCord + (fontSize * 2) + choiceLength - (fontSize * 2.5),
                        yCord + (fontSize * 3) + yViewOffset + dialogHeight,
                        false
                    );
                    
                    if (mouse_check_button_released(mb_left))
                    {
                        input = i;
                        finish = true;
                    }
                }
                
                choiceLength += (string_width(choices[i]) * fontScale) + fontSize * 3;
            }
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
